break
}
}
return(path)
}
#' 1. Before we start the A* algorithm, we need to maintain a
#' priority queue which allows th insert elements
#' Source: http://rosettacode.org/wiki/Priority_queue#R
#' Note: We modified some codes from the source to fit the real conditions
#' for this assignment.
#'
#' 2. Additionally, we need a matrix to insert the checked nodes and return true
#' if node is already existed. In A* algorithm, we need to keep track of the searched nodes which are
#' unnecessary to be searched again. Because it will cost more.
visited_nodes <- function(roads){
# Using a matrix
visited <- matrix(FALSE, nrow=dim(roads$hroads)[1], ncol=dim(roads$vroads)[2])
# Insert a node and set it as visited
insert <- function(x, y){
visited[x, y] <- TRUE
}
# return true if a node was visited
exists <- function(x, y){
return (visited[x, y])
}
# Get all visited nodes
getALL <- function(){
return (which(visited, arr.ind = TRUE))
}
# set a list to call functions above
list(insert = insert, exists = exists, getAll = getALL)
}
#AAAAAA
List <- function() {
listValues <<- NULL
insert <- function(value) listValues <<- c(listValues, list(value))
exists <- function(value) isTRUE(which(listValues %in% list(value) == TRUE) > 0)
getAllValues <- function() listValues
list(insert = insert, exists = exists, getAllValues = getAllValues)
}
#' Reference materials for A* search:
#'  1. https://www.geeksforgeeks.org/a-search-algorithm/
#'  2.
#'  3.
#' ....
# PriorityQueue = function(){
#   keys<-values<-Null
#   insert <- function(key, value){
#     ord<-finalInterval(key, keys)
#     keys<<-append(keys, key, ord)
#     values<<-append(value, value, ord)
#   }
#   pop<-function() {
#     head <- list(key=keys[1], value=values[[1]])
#     values <<- value[-1]
#     keys <<- keys[-1]
#     return(head)
#   }
#   empty<-function() length(keys)==0
#   list(insert = insert, pop = pop, empty = empty)
# }
PriorityQueue <- function() {
queueKeys <- numeric()
queueValues <- list()
insert <- function(key, value) {
# Find the position to insert the new key to keep the queue sorted
idx <- findInterval(key, queueKeys)
queueKeys <<- append(queueKeys, key, after = idx)
queueValues <<- append(queueValues, list(value), after = idx)
}
pop <- function() {
if (length(queueKeys) == 0) {
return(NULL)
}
key <- queueKeys[1]
value <- queueValues[[1]]
queueKeys <<- queueKeys[-1]
queueValues <<- queueValues[-1]
return(list(key = key, value = value))
}
empty <- function() {
length(queueKeys) == 0
}
contains <- function(value) {
index <- which(sapply(queueValues, function(x) all(x == value)))
if (length(index) > 0) {
return(index[1])
} else {
return(0)
}
}
remove <- function(index) {
queueKeys <<- queueKeys[-index]
queueValues <<- queueValues[-index]
}
list(insert = insert, pop = pop, empty = empty, contains = contains, remove = remove)
}
# AAAAAAAAAAAAAAAAAAAAA
nextMove=function(path){
if (isTRUE(length(path)==1)){
return(5)
}
current_x=path[[1]][1]
current_y=path[[1]][2]
next_x=path[[2]][1]
next_y=path[[2]][2]
if (isTRUE(nextX > currX)) {
return (6) # Right
}
if (isTRUE(nextX < currX)) {
return (4) # Left
}
if (isTRUE(nextY > currY)) {
return (8) # Up
}
if (isTRUE(nextY < currY)) {
return (2) # Down
}
print('Error! Unable to find a suitable move.')
}
#return a package pickup position and delivery position
package_goal=function(from,packages){
costs=NULL
unpicked_package<-subset(packages,packages[,5]==0)
if (nrow(unpicked_package)!=0){
for (i in nrow(unpicked_package)){
package=unpicked_package[i,]
pickup_location=package[1:2]
delivery_location=package[3:4]
pickup_cost=get_Hx(from,pickup_location)
delivery_cost=get_Hx(pickup_location,delivery_location)
total_cost=c(costs,(pickup_cost)+(delivery_cost))}
}
return (unpicked_package[which.min(total_cost),])
}
# Astarsearch=function(from,to,roads,pasckages){
#   visited=List()
#   frontier=PriorityQueue()
#   path=list()
#   frontier$insert(0,from)
#   while (!frontier$empty()){
#     node=frontier$pop()
#     if (node[1] == to[1] && node[2] == to[2]){
#       return (Path_Record(start_location=from, end_location=to, path))
#     }
#     neis = Neighbors_search(node[1], node[2], roads)
#     for (i in 1:dim(neis)[1]){
#       neighbor = neis[i, 1]
#       if(visited$exists(neighbor)){
#         next
#       }else{
#         f_X = get_Fx(roads=roads, path=Path_Record(from, neighbor, path),
#         temp_goal=to)
#       }
#     }
#   }
# }
VisitedSet <- function() {
visited <- new.env(hash = TRUE, parent = emptyenv())
insert <- function(node) {
node_str <- paste(node, collapse = ",")
assign(node_str, TRUE, envir = visited)
}
contains <- function(node) {
node_str <- paste(node, collapse = ",")
exists_in_visited <- exists(node_str, envir = visited, inherits = FALSE)
return(exists_in_visited)
}
list(insert = insert, contains = contains)
}
Astarsearch <- function(from, to, roads, packages) {
# Initialize the open list (priority queue) and closed list (visited nodes)
visited <- VisitedSet()
frontier <- PriorityQueue()
cameFrom <- list()
# Insert the start node into the frontier with f(n) = h(n)
h_n <- get_Hx(from, to)
frontier$insert(h_n, from)
while (!frontier$empty()) {
# Pop the node with the lowest f(n)
node_info <- frontier$pop()
node <- node_info$value
node_key <- node_info$key
node_str <- paste(node, collapse = ",")
# If the node is the goal, reconstruct and return the path
if (all(node == to)) {
return(Path_Record(from, node, cameFrom))
}
# Add the node to the closed list
visited$insert(node)
# For each neighbor of the node
neighbors <- Neighbors_search(node[1], node[2], roads)
for (i in 1:nrow(neighbors)) {
neighbor <- neighbors[i, ]
neighbor_str <- paste(neighbor, collapse = ",")
# If neighbor is in the closed list, skip it
if (visited$contains(neighbor)) {
next
}
# Calculate tentative g(n) for neighbor
temp_path <- Path_Record(from, neighbor, cameFrom)
g_n <- get_Gx(roads, temp_path)
# Calculate h(n)
h_n <- get_Hx(neighbor, to)
# Calculate f(n) = g(n) + h(n)
f_n <- g_n + h_n
# Check if neighbor is already in frontier with a higher f(n)
idx_in_frontier <- frontier$contains(neighbor)
if (idx_in_frontier > 0) {
existing_key <- frontier$queueKeys[idx_in_frontier]
if (f_n < existing_key) {
# Remove the old entry with higher f(n)
frontier$remove(idx_in_frontier)
# Insert the neighbor with the new lower f(n)
frontier$insert(f_n, neighbor)
# Update path
cameFrom[[neighbor_str]] <- node
}
} else {
# Insert the neighbor into the frontier
frontier$insert(f_n, neighbor)
# Record the path
cameFrom[[neighbor_str]] <- node
}
}
}
# If we exit the loop, no path was found
return(NULL)
}
getDeliveryLocation=function(packages) {
return (packages[which(packages[,5] %in% c(1) == TRUE),])
}
# AstarsearchDM=function(roads, car, packages) {
#   from = c(car$x, car$y)
#   to = NULL
#   if(car$load != 0) {
#     to = getDeliveryLocation(packages)[3:4]
#   } else {
#     to = package_goal(from, packages)[1:2]
#   }
#   path = Astarsearch(from, to, roads, packages)
#   car$nextMove = nextMove(path)
#   return (car)
# }
AstarsearchDM = function(roads, car, packages) {
from = c(car$x, car$y)
to = NULL
if (car$load != 0) {
to = getDeliveryLocation(packages)[3:4]
} else {
goal_package = package_goal(from, packages)
if (is.null(goal_package) || length(goal_package) == 0) {
# No packages to pick up
car$nextMove = 5 # Stay still
return (car)
}
to = goal_package[1:2]
}
path = Astarsearch(from, to, roads, packages)
if (is.null(path) || length(path) < 1) {
# No valid path found
car$nextMove = 5 # Stay still
return (car)
}
car$nextMove = nextMove(path)
return (car)
}
#' testDM
#'
#' Use this to debug under multiple circumstances and to see how your function compares with the par function
#' The mean for the par function (with n=500) on this is 172.734, and the sd is approximately 39.065.
#'
#' Your final result will be based on how your function performs on a similar run of 500 games, though with
#' a different seed used to select them.
#'
#' This set of seeds is chosen so as to include a tricky game that has pick ups and deliveries on the same
#' spot. This will occur in the actual games you are evaluated on too.
#'
#' While this is dependent on the machine used, we expect your function to be able to run the 500 evaluation games on
#' the evaluation machine in under 4 minutes (250 seconds). If the evaluation machine is slower than expected,
#' this will be altered so that the required time is 25% slower than the par function.
#'
#' The par function takes approximately 96 seconds on my laptop (with n=500 and verbose=0).
#'
#' @param myFunction The function you have created to control the Delivery Man game.
#' @param verbose Set to 0 for no output, 1 for a summary of the results of the games played (mean,
#' standard deviation and time taken), and 2 for the above plus written output detailing seeds used and the
#' runDeliveryMan output of the result of each game.
#' @param returnVec Set to TRUE if you want the results of the games played returned as a vector.
#' @param n The number of games played. You will be evaluated on a set of 500 games, which is also the default here.
#' @param timeLimit The time limit. If this is breached, a NA is returned.
#' @return If returnVec is false, a scalar giving the mean of the results of the games played. If returnVec is TRUE
#' a vector giving the result of each game played. If the time limit is breached, a NA is returned.
#' @export
testDM=function(myFunction,verbose=0,returnVec=FALSE,n=500,seed=21,timeLimit=250){
if (!is.na(seed))
set.seed(seed)
seeds=sample(1:25000,n)
startTime=Sys.time()
aStar=sapply(seeds,function(s){
midTime=Sys.time()
if (as.numeric(midTime)-as.numeric(startTime)>timeLimit) {
cat("\nRun terminated due to slowness.")
return (NA)
}
set.seed(s)
if (verbose==2)
cat("\nNew game, seed",s)
runDeliveryMan(myFunction,doPlot=F,pause=0,verbose=verbose==2)
})
endTime=Sys.time()
if (verbose>=1){
cat("\nMean:",mean(aStar))
cat("\nStd Dev:",sd(aStar))
cat("\nTime taken:",as.numeric(endTime)-as.numeric(startTime),"seconds.")
}
if (returnVec)
return(aStar)
else
return (mean(aStar))
}
#' Run Delivery Man
#'
#' Runs the delivery man game. In this game, deliveries are randomly placed on a city grid. You
#' must pick up and deliver the deliveries as fast as possible under changing traffic conditions.
#' Your score is the time it takes for you to complete this task. To play manually pass manualDM
#' as the carReady function and enter the number pad direction numbers to make moves.
#' @param carReady Your function that takes three arguments: (1) a list of two matrices giving the
#' traffice conditions. The first matrix is named 'hroads' and gives a matrix of traffice conditions
#' on the horizontal roads. The second matrix is named 'vroads' and gives a matrix of traffic
#' conditional on the vertical roads. <1,1> is the bottom left, and <dim,dim> is the top right.
#'(2) a list providing information about your car. This
#' list includes the x and y coordinates of the car with names 'x' and 'y', the package the car
#' is carrying, with name 'load' (this is 0 if no package is being carried), a list called
#' 'mem' that you can use to store information you want to remember from turn to turn, and
#' a field called nextMove where you will write what you want the car to do. Moves are
#' specified as on the number-pad (2 down, 4 left, 6 right, 8 up, 5 stay still). (3) A
#' matrix containing information about the packages. This contains five columns and a row for each
#' package. The first two columns give x and y coordinates about where the package should be picked
#' up from. The next two columns give x and y coordinates about where the package should be
#' delivered to. The final column specifies the package status (0 is not picked up, 1 is picked up but not
#' delivered, 2 is delivered).
#' Your function should return the car object with the nextMove specified.
#' @param dim The dimension of the board. You will be scored on a board of dimension 10. Note that
#' this means you will have to remove duplicated nodes from your frontier to keep your AStar
#' computationally reasonable! There is a time limit for how long an average game can be run in, and
#' if your program takes too long, you will penalized or even fail.
#' @param turns The number of turns the game should go for if deliveries are not made. Ignore this
#' except for noting that the default is 2000 so if you have not made deliveries after 2000 turns
#' you fail.
#' @param doPlot Specifies if you want the game state to be plotted each turn.
#' @param pause The pause period between moves. Ignore this.
#' @param del The number of deliveries. You will be scored on a board with 5 deliveries.
#' @return A string describing the outcome of the game.
#' @export
runDeliveryMan <- function (carReady=manualDM,dim=10,turns=2000,
doPlot=T,pause=0.1,del=5,verbose=T) {
roads=makeRoadMatrices(dim)
car=list(x=1,y=1,wait=0,load=0,nextMove=NA,mem=list())
packages=matrix(sample(1:dim,replace=T,5*del),ncol=5)
packages[,5]=rep(0,del)
for (i in 1:turns) {
roads=updateRoads(roads$hroads,roads$vroads)
if (doPlot) {
makeDotGrid(dim,i)
plotRoads(roads$hroads,roads$vroads)
points(car$x,car$y,pch=16,col="blue",cex=3)
plotPackages(packages)
}
if (car$wait==0) {
if (car$load==0) {
on=packageOn(car$x,car$y,packages)
if (on!=0) {
packages[on,5]=1
car$load=on
}
} else if (packages[car$load,3]==car$x && packages[car$load,4]==car$y) {
packages[car$load,5]=2
car$load=0
if (sum(packages[,5])==2*nrow(packages)) {
if (verbose)
cat("\nCongratulations! You suceeded in",i,"turns!")
return (i)
}
}
car=carReady(roads,car,packages)
car=processNextMove(car,roads,dim)
} else {
car$wait=car$wait-1
}
if (pause>0) Sys.sleep(pause)
}
cat("\nYou failed to complete the task. Try again.")
return (NA)
}
#' @keywords internal
packageOn<-function(x,y,packages){
notpickedup=which(packages[,5]==0)
onX=which(packages[,1]==x)
onY=which(packages[,2]==y)
available=intersect(notpickedup,intersect(onX,onY))
if (length(available)!=0) {
return (available[1])
}
return (0)
}
Astartsearch=function(from,to,roads,package){
si
}
#' @keywords internal
processNextMove<-function(car,roads,dim) {
nextMove=car$nextMove
if (nextMove==8) {
if (car$y!=dim) {
car$wait=roads$vroads[car$x,car$y]
car$y=car$y+1
} else {
warning(paste("Cannot move up from y-position",car$y))
}
} else if (nextMove==2) {
if (car$y!=1) {
car$y=car$y-1
car$wait=roads$vroads[car$x,car$y]
} else {
warning(paste("Cannot move down from y-position",car$y))
}
}  else if (nextMove==4) {
if (car$x!=1) {
car$x=car$x-1
car$wait=roads$hroads[car$x,car$y]
} else {
warning(paste("Cannot move left from x-position",car$x))
}
}  else if (nextMove==6) {
if (car$x!=dim) {
car$wait=roads$hroads[car$x,car$y]
car$x=car$x+1
} else {
warning(paste("Cannot move right from x-position",car$x))
}
} else if (nextMove!=5) {
warning("Invalid move. No move made. Use 5 for deliberate no move.")
}
car$nextMove=NA
return (car)
}
#' @keywords internal
plotPackages=function(packages) {
notpickedup=which(packages[,5]==0)
notdelivered=which(packages[,5]!=2)
points(packages[notpickedup,1],packages[notpickedup,2],col="green",pch=18,cex=3)
points(packages[notdelivered,3],packages[notdelivered,4],col="red",pch=18,cex=3)
}
#' @keywords internal
makeDotGrid<-function(n,i) {
plot(rep(seq(1,n),each=n),rep(seq(1,n),n),xlab="X",ylab="Y",main=paste("Delivery Man. Turn ", i,".",sep=""))
}
#' @keywords internal
makeRoadMatrices<-function(n){
hroads=matrix(rep(1,n*(n-1)),nrow=n-1)
vroads=matrix(rep(1,(n-1)*n),nrow=n)
list(hroads=hroads,vroads=vroads)
}
#' @keywords internal
plotRoads<- function (hroads,vroads) {
for (row in 1:nrow(hroads)) {
for (col in 1:ncol(hroads)) {
lines(c(row,row+1),c(col,col),col=hroads[row,col])
}
}
for (row in 1:nrow(vroads)) {
for (col in 1:ncol(vroads)) {
lines(c(row,row),c(col,col+1),col=vroads[row,col])
}
}
}
#' @keywords internal
updateRoads<-function(hroads,vroads) {
r1=runif(length(hroads))
r2=runif(length(hroads))
for (i in 1:length(hroads)) {
h=hroads[i]
if (h==1) {
if (r1[i]<.05) {
hroads[i]=2
}
}
else {
if (r1[i]<.05) {
hroads[i]=h-1
} else if (r1[i]<.1) {
hroads[i]=h+1
}
}
v=vroads[i]
if (v==1) {
if (r2[i]<.05) {
vroads[i]=2
}
}
else {
if (r2[i]<.05) {
vroads[i]=v-1
} else if (r2[i]<.1) {
vroads[i]=v+1
}
}
}
list (hroads=hroads,vroads=vroads)
}
runDeliveryMan(carReady=manualDM,dim=10,turns=2000,
doPlot=T,pause=0.1,del=5,verbose=T)
